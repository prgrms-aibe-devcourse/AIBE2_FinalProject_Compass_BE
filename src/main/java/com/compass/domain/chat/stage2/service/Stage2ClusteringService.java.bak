package com.compass.domain.chat.stage2.service;

import com.compass.domain.chat.entity.TravelCandidate;
import com.compass.domain.chat.function.processing.phase3.date_selection.model.TourPlace;
import com.compass.domain.chat.function.processing.phase3.date_selection.model.cluster.Cluster;
import com.compass.domain.chat.function.processing.phase3.date_selection.model.cluster.Point;
import com.compass.domain.chat.function.processing.phase3.date_selection.service.KMeansClusteringService;
import com.compass.domain.chat.model.TravelPlace;
import com.compass.domain.chat.repository.TravelCandidateRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.*;
import java.util.stream.Collectors;

// Stage 2: 사용자 선택 기반 클러스터링 및 거리 기반 장소 추천
@Slf4j
@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class Stage2ClusteringService {

    private final TravelCandidateRepository travelCandidateRepository;
    private final KMeansClusteringService kMeansClusteringService;

    private static final double MAX_WALKABLE_DISTANCE_KM = 2.0; // 도보 가능 거리
    private static final double MAX_CLUSTER_RADIUS_KM = 5.0; // 클러스터 최대 반경
    private static final int PLACES_PER_CLUSTER = 10; // 클러스터당 추천 장소 수

    // 사용자 선택 기반 클러스터링 및 추천
    public Stage2Response processUserSelection(Stage2Request request) {
        log.info("Stage 2: 사용자 선택 기반 클러스터링 시작");

        // 1. 사용자 선택 장소들로 초기 클러스터 형성
        List<Cluster> initialClusters = createInitialClusters(request.selectedPlaces());
        log.info("초기 클러스터 {}개 생성", initialClusters.size());

        // 2. 각 클러스터 주변 추가 장소 찾기
        Map<String, List<TravelPlace>> clusterRecommendations = new HashMap<>();

        for (Cluster cluster : initialClusters) {
            String clusterId = "cluster_" + initialClusters.indexOf(cluster);
            List<TravelPlace> nearbyPlaces = findNearbyPlaces(
                cluster,
                request.destination(),
                request.selectedPlaces()
            );
            clusterRecommendations.put(clusterId, nearbyPlaces);

            log.info("클러스터 {}: 중심({:.4f}, {:.4f}), 추천 장소 {}개",
                clusterId,
                cluster.getCenter().getLat(),
                cluster.getCenter().getLng(),
                nearbyPlaces.size()
            );
        }

        // 3. 일자별 분배 계획 생성
        Map<Integer, DayPlan> dayPlans = distributeToDays(
            initialClusters,
            clusterRecommendations,
            request.tripDays()
        );

        // 4. 응답 생성
        return Stage2Response.builder()
            .threadId(request.threadId())
            .clusters(convertClustersToResponse(initialClusters))
            .clusterRecommendations(clusterRecommendations)
            .dayPlans(dayPlans)
            .totalRecommended(countTotalRecommended(clusterRecommendations))
            .build();
    }

    // 사용자 선택 장소들로 초기 클러스터 형성
    private List<Cluster> createInitialClusters(List<SelectedPlace> selectedPlaces) {
        if (selectedPlaces.size() <= 3) {
            // 3개 이하면 하나의 클러스터로
            return List.of(createSingleCluster(selectedPlaces));
        }

        // 선택된 장소들을 TourPlace로 변환
        List<TourPlace> tourPlaces = selectedPlaces.stream()
            .map(this::convertToTourPlace)
            .collect(Collectors.toList());

        // K-means 클러스터링 수행 (k는 선택 장소 수에 따라 동적 결정)
        int k = determineOptimalK(selectedPlaces.size());
        List<Cluster> clusters = kMeansClusteringService.performKMeansClustering(tourPlaces, k);

        // 빈 클러스터 제거
        return clusters.stream()
            .filter(c -> !c.getPoints().isEmpty())
            .collect(Collectors.toList());
    }

    // 단일 클러스터 생성
    private Cluster createSingleCluster(List<SelectedPlace> places) {
        List<Point> points = places.stream()
            .map(p -> new Point(p.latitude(), p.longitude()))
            .collect(Collectors.toList());

        // 중심점 계산
        double avgLat = points.stream().mapToDouble(Point::getLat).average().orElse(0);
        double avgLng = points.stream().mapToDouble(Point::getLng).average().orElse(0);

        return new Cluster(new Point(avgLat, avgLng), points);
    }

    // 최적 클러스터 수 결정
    private int determineOptimalK(int placeCount) {
        if (placeCount <= 3) return 1;
        if (placeCount <= 6) return 2;
        if (placeCount <= 9) return 3;
        return Math.min(4, (placeCount + 2) / 3);
    }

    // 클러스터 주변 추가 장소 찾기
    private List<TravelPlace> findNearbyPlaces(Cluster cluster,
                                              String destination,
                                              List<SelectedPlace> excludePlaces) {
        Point center = cluster.getCenter();

        // DB에서 해당 지역의 모든 후보 가져오기
        List<TravelCandidate> candidates = travelCandidateRepository.findByRegion(destination);

        // 이미 선택된 장소 제외
        Set<String> excludeIds = excludePlaces.stream()
            .map(SelectedPlace::placeId)
            .collect(Collectors.toSet());

        // 거리 기반 필터링 및 점수 계산
        List<ScoredPlace> scoredPlaces = candidates.stream()
            .filter(c -> !excludeIds.contains(c.getPlaceId()))
            .map(c -> calculatePlaceScore(c, center))
            .filter(sp -> sp.distance() <= MAX_CLUSTER_RADIUS_KM)
            .sorted(Comparator.comparing(ScoredPlace::score).reversed())
            .limit(PLACES_PER_CLUSTER)
            .collect(Collectors.toList());

        // TravelPlace로 변환
        return scoredPlaces.stream()
            .map(sp -> convertCandidateToTravelPlace(sp.candidate()))
            .collect(Collectors.toList());
    }

    // 장소 점수 계산 (거리 + 품질)
    private ScoredPlace calculatePlaceScore(TravelCandidate candidate, Point center) {
        double distance = calculateDistance(
            center.getLat(), center.getLng(),
            candidate.getLatitude(), candidate.getLongitude()
        );

        // 거리 점수 (가까울수록 높음)
        double distanceScore = Math.max(0, 1.0 - (distance / MAX_CLUSTER_RADIUS_KM));

        // 품질 점수 (평점과 리뷰수 고려)
        double qualityScore = 0.0;
        if (candidate.getRating() != null) {
            qualityScore += (candidate.getRating() / 5.0) * 0.7;
        }
        if (candidate.getReviewCount() != null) {
            double reviewScore = Math.min(1.0, Math.log10(candidate.getReviewCount() + 1) / 3);
            qualityScore += reviewScore * 0.3;
        }

        // 카테고리 다양성 보너스
        double diversityBonus = getCategoryDiversityBonus(candidate.getCategory());

        // 최종 점수: 거리 40%, 품질 40%, 다양성 20%
        double totalScore = (distanceScore * 0.4) + (qualityScore * 0.4) + (diversityBonus * 0.2);

        return new ScoredPlace(candidate, distance, totalScore);
    }

    // 카테고리 다양성 보너스
    private double getCategoryDiversityBonus(String category) {
        // 다양한 카테고리에 보너스 부여
        if (category == null) return 0.0;

        return switch (category) {
            case "맛집", "음식" -> 0.9;  // 식사는 필수
            case "관광명소", "관광지" -> 0.8;
            case "카페", "베이커리" -> 0.7;
            case "액티비티", "체험" -> 0.6;
            case "쇼핑" -> 0.5;
            default -> 0.4;
        };
    }

    // Haversine 거리 계산
    private double calculateDistance(double lat1, double lon1, double lat2, double lon2) {
        double R = 6371; // 지구 반경 (km)
        double dLat = Math.toRadians(lat2 - lat1);
        double dLon = Math.toRadians(lon2 - lon1);
        double a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                  Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2)) *
                  Math.sin(dLon/2) * Math.sin(dLon/2);
        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c;
    }

    // 일자별 분배
    private Map<Integer, DayPlan> distributeToDays(List<Cluster> clusters,
                                                  Map<String, List<TravelPlace>> recommendations,
                                                  int tripDays) {
        Map<Integer, DayPlan> dayPlans = new HashMap<>();

        // 간단한 분배: 클러스터를 일수로 나누기
        int clustersPerDay = Math.max(1, (clusters.size() + tripDays - 1) / tripDays);

        for (int day = 1; day <= tripDays; day++) {
            int startIdx = (day - 1) * clustersPerDay;
            int endIdx = Math.min(startIdx + clustersPerDay, clusters.size());

            List<String> dayClusterIds = new ArrayList<>();
            List<TravelPlace> dayPlaces = new ArrayList<>();

            for (int i = startIdx; i < endIdx; i++) {
                String clusterId = "cluster_" + i;
                dayClusterIds.add(clusterId);
                dayPlaces.addAll(recommendations.getOrDefault(clusterId, List.of()));
            }

            dayPlans.put(day, new DayPlan(day, dayClusterIds, dayPlaces));
        }

        return dayPlans;
    }

    // SelectedPlace를 TourPlace로 변환
    private TourPlace convertToTourPlace(SelectedPlace place) {
        return TourPlace.builder()
            .id(place.placeId())
            .name(place.name())
            .category(place.category())
            .latitude(place.latitude())
            .longitude(place.longitude())
            .address(place.address())
            .rating(place.rating())
            .build();
    }

    // TravelCandidate를 TravelPlace로 변환
    private TravelPlace convertCandidateToTravelPlace(TravelCandidate candidate) {
        return TravelPlace.builder()
            .placeId(candidate.getPlaceId())
            .name(candidate.getName())
            .category(candidate.getCategory())
            .latitude(candidate.getLatitude())
            .longitude(candidate.getLongitude())
            .address(candidate.getAddress())
            .rating(candidate.getRating())
            .reviewCount(candidate.getReviewCount())
            .priceLevel(candidate.getPriceLevel())
            .photoUrl(candidate.getPhotoUrl())
            .description(candidate.getDescription())
            .build();
    }

    // Cluster를 응답용 형태로 변환
    private List<ClusterInfo> convertClustersToResponse(List<Cluster> clusters) {
        return clusters.stream()
            .map(c -> new ClusterInfo(
                c.getCenter().getLat(),
                c.getCenter().getLng(),
                c.getPoints().size(),
                calculateClusterRadius(c)
            ))
            .collect(Collectors.toList());
    }

    // 클러스터 반경 계산
    private double calculateClusterRadius(Cluster cluster) {
        Point center = cluster.getCenter();
        return cluster.getPoints().stream()
            .mapToDouble(p -> calculateDistance(
                center.getLat(), center.getLng(),
                p.getLat(), p.getLng()
            ))
            .max()
            .orElse(0);
    }

    // 전체 추천 장소 수 계산
    private int countTotalRecommended(Map<String, List<TravelPlace>> recommendations) {
        return recommendations.values().stream()
            .mapToInt(List::size)
            .sum();
    }

    // 요청 DTO
    public record Stage2Request(
        String threadId,
        String destination,
        List<SelectedPlace> selectedPlaces,
        int tripDays
    ) {}

    // 선택된 장소 DTO
    public record SelectedPlace(
        String placeId,
        String name,
        String category,
        double latitude,
        double longitude,
        String address,
        Double rating
    ) {}

    // 점수가 계산된 장소
    private record ScoredPlace(
        TravelCandidate candidate,
        double distance,
        double score
    ) {}

    // 클러스터 정보
    public record ClusterInfo(
        double centerLat,
        double centerLng,
        int placeCount,
        double radius
    ) {}

    // 일별 계획
    public record DayPlan(
        int day,
        List<String> clusterIds,
        List<TravelPlace> recommendedPlaces
    ) {}

    // Stage 2 응답 DTO
    public record Stage2Response(
        String threadId,
        List<ClusterInfo> clusters,
        Map<String, List<TravelPlace>> clusterRecommendations,
        Map<Integer, DayPlan> dayPlans,
        int totalRecommended
    ) {
        public static Builder builder() {
            return new Builder();
        }

        public static class Builder {
            private String threadId;
            private List<ClusterInfo> clusters;
            private Map<String, List<TravelPlace>> clusterRecommendations;
            private Map<Integer, DayPlan> dayPlans;
            private int totalRecommended;

            public Builder threadId(String threadId) {
                this.threadId = threadId;
                return this;
            }

            public Builder clusters(List<ClusterInfo> clusters) {
                this.clusters = clusters;
                return this;
            }

            public Builder clusterRecommendations(Map<String, List<TravelPlace>> clusterRecommendations) {
                this.clusterRecommendations = clusterRecommendations;
                return this;
            }

            public Builder dayPlans(Map<Integer, DayPlan> dayPlans) {
                this.dayPlans = dayPlans;
                return this;
            }

            public Builder totalRecommended(int totalRecommended) {
                this.totalRecommended = totalRecommended;
                return this;
            }

            public Stage2Response build() {
                return new Stage2Response(threadId, clusters, clusterRecommendations, dayPlans, totalRecommended);
            }
        }
    }
}