# 프로젝트 코드 컨벤션 전체 가이드

## 🎯 핵심 철학
- **AI 코딩 흔적 제거**: 인간이 작성한 것처럼 자연스럽고 점진적인 코드
- **일관성 유지**: 팀 전체가 동일한 스타일로 작성
- **클린코드 원칙**: 읽기 쉽고, 수정하기 쉽고, 테스트하기 쉬운 코드

## 📋 요구사항 세분화 규칙

### 계층 구조 (에픽-스토리-태스크)
```
Epic (2-4주) → Story (3-5일) → Task (2-4시간)
```

#### Epic (에픽) - 대규모 기능 단위
- **정의**: 2-4주 단위의 대규모 기능 개발
- **예시**: "여행 정보 수집 시스템 구축", "LLM 통합 파이프라인 구현"
- **산출물**: 완성된 기능 모듈, 통합 테스트, 문서화

#### Story (스토리) - 사용자 관점 기능
- **정의**: 3-5일 단위의 사용자 스토리
- **형식**: "As a [사용자], I want [기능] so that [가치]"
- **예시**: "사용자로서 여행 날짜를 입력하고 싶다"
- **산출물**: 동작하는 기능, 단위 테스트, API 문서

#### Task (태스크) - 개발 작업 단위
- **정의**: 2-4시간 단위의 구체적 개발 작업
- **예시**: "TravelInfoDto Record 구현", "날짜 검증 로직 추가"
- **산출물**: 코드 구현, 테스트 코드, 코드 리뷰

### PR 규칙
- **최대 300줄**: 실제 로직 ~150줄 + 테스트 ~100줄 + 설정/문서 ~50줄
- **단일 책임**: 한 PR = 한 가지 Task 구현
- **독립성**: 개별 테스트 및 롤백 가능
- **태스크 기반**: 각 PR은 하나의 Task를 완료

### SMART 원칙
- **S**pecific: 구체적이고 명확한 정의
- **M**easurable: 완료 기준이 측정 가능
- **A**chievable: 현실적으로 달성 가능
- **R**elevant: 프로젝트 목표와 연관
- **T**ime-bound: 시간 제한 존재

## ✅ Java 17 & Lombok 필수 사용

### 1. DTO → Record 사용
```java
// DTO는 무조건 Record
public record TravelRequest(
    String destination,
    LocalDate startDate,
    LocalDate endDate,
    Integer budget
) {}

// 검증 로직 포함 가능
public record TravelInfoDto(
    String destination,
    LocalDate startDate,
    LocalDate endDate
) {
    public TravelInfoDto {
        if (startDate.isAfter(endDate)) {
            throw new IllegalArgumentException("시작일이 종료일보다 늦음");
        }
    }
}
```

### 2. Entity → Lombok 사용
```java
@Entity
@Table(name = "travels")
@Getter @Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Travel {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String destination;

    private LocalDate startDate;
    private LocalDate endDate;
    private Integer budget;

    @Enumerated(EnumType.STRING)
    private TravelStatus status;
}
```

### 3. Service → @RequiredArgsConstructor
```java
@Service
@RequiredArgsConstructor
@Slf4j
public class TravelService {

    private final TravelRepository travelRepository;
    private final TravelValidator validator;

    // 여행 생성
    public TravelResponse createTravel(TravelRequest request) {
        validator.validate(request);

        var travel = Travel.builder()
            .destination(request.destination())
            .startDate(request.startDate())
            .endDate(request.endDate())
            .budget(request.budget())
            .status(TravelStatus.PLANNED)
            .build();

        var saved = travelRepository.save(travel);
        return toResponse(saved);
    }
}
```

### 4. Controller 구조
```java
@RestController
@RequestMapping("/api/travels")
@RequiredArgsConstructor
@Slf4j
public class TravelController {

    private final TravelService travelService;

    @PostMapping
    public ResponseEntity<TravelResponse> createTravel(
            @RequestBody @Valid TravelRequest request) {
        var response = travelService.createTravel(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }
}
```

## 📝 주석 스타일 가이드

### ✅ // 주석만 사용 (한국어, 간결)
```java
// 여행 서비스
@Service
public class TravelService {

    // 여행 정보 처리
    public TravelResponse processTravel(TravelRequest request) {
        // 요청 검증
        validateRequest(request);

        // 날짜 체크
        if (request.startDate().isAfter(request.endDate())) {
            throw new InvalidDateException("시작일이 종료일보다 늦음");
        }

        // 예산 계산: 1인당 * 인원수
        int total = perPerson * count;

        return response;
    }

    // 메서드명이 명확하면 주석 생략
    public String getDestination() {
        return destination;
    }
}
```

### ❌ 금지된 주석 스타일
```java
/**
 * JavaDoc 스타일 금지
 */
/* 블록 주석 금지 */
// This is prohibited (영어 주석 금지)
// 불필요하게 긴 설명 주석 금지
```

## 🔧 Java 17 기능 활용

### 1. var 사용 (타입 명확할 때만)
```java
// ✅ 좋은 예
var travelList = new ArrayList<Travel>();
var response = travelService.findById(id);

// ❌ 나쁜 예
var data = process();  // 타입 불명확
```

### 2. Switch Expression
```java
public String getTravelType(String category) {
    return switch (category) {
        case "BUDGET" -> "경제적 여행";
        case "LUXURY" -> "럭셔리 여행";
        default -> "일반 여행";
    };
}
```

### 3. Text Blocks (SQL, JSON)
```java
String sql = """
    SELECT * FROM travel
    WHERE user_id = ?
    AND status = 'ACTIVE'
    """;
```

### 4. 불변 컬렉션
```java
List<String> cities = List.of("서울", "부산", "제주");
Map<String, Integer> prices = Map.of(
    "서울", 100000,
    "부산", 150000
);
```

## 📏 코드 작성 규칙

### 메서드 규칙
- **최대 20줄** (이상적으로 10줄)
- **단일 책임**: 한 메서드 = 한 가지 일
- **명확한 네이밍**: 동사 + 명사

### 클래스 규칙
- **최대 200줄**
- **단일 책임 원칙**
- **관련 기능만 포함**

### 네이밍 컨벤션
```java
// 클래스: PascalCase
public class TravelService {}

// 메서드: camelCase
public TravelDto findById(Long id) {}

// 상수: UPPER_SNAKE_CASE
private static final int MAX_RETRY_COUNT = 3;

// 패키지: lowercase
package com.compass.travel;
```

## 🚫 금지 사항
1. **getter/setter 직접 작성 금지** → Lombok 사용
2. **생성자 직접 작성 금지** → @RequiredArgsConstructor, @Builder
3. **한 번에 전체 CRUD 구현 금지** → 점진적 구현
4. **/* */ /** */ 주석 금지** → // 만 사용
5. **영어 주석 금지** → 한국어만
6. **불필요한 주석 금지** → 코드로 의도 표현
7. **300줄 넘는 PR 금지** → 작은 단위로 분할
8. **TODO 남발 금지** → 필요시만 최소한

## 📝 AI 코드 생성 프로토콜

### 생성 전 필수 체크
1. **코드베이스 전체 분석**
   - 기존 패턴 파악
   - 네이밍 컨벤션 확인
   - 의존성 관계 이해

2. **작성 단위**
   - 한 번에 150-200줄
   - 단일 기능만 구현

3. **필수 설명**
   ```markdown
   ## 작성 코드 정보
   - **위치**: src/main/java/com/compass/...
   - **목적**: [구체적 기능]
   - **의존성**: [사용하는 컴포넌트]
   - **사용처**: [이 코드를 사용할 곳]
   - **영향범위**: [변경 영향]
   ```

## 🔍 최종 체크리스트

```yaml
Java 17 & Lombok:
  ✓ DTO는 Record 사용
  ✓ Entity는 Lombok 사용
  ✓ Service는 @RequiredArgsConstructor
  ✓ var는 타입 명확할 때만
  ✓ Switch Expression 활용
  ✓ Text Block 활용 (SQL, JSON)

코드 품질:
  ✓ 메서드 20줄 이내
  ✓ 클래스 200줄 이내
  ✓ PR 300줄 이내
  ✓ 단일 책임 원칙
  ✓ Optional 활용

주석 규칙:
  ✓ // 주석만 사용
  ✓ 한국어로 간결하게
  ✓ 불필요한 주석 제거
  ✓ 코드가 명확하면 주석 생략

일관성:
  ✓ 기존 코드 패턴 준수
  ✓ 팀 네이밍 컨벤션 준수
  ✓ 점진적 개선 (완벽한 첫 구현 X)
```

## 💡 핵심 기억사항
- **인간적인 코드**: AI가 생성했다는 흔적이 없는 자연스러운 코드
- **작은 단위 작업**: 한 번에 하나씩, 명확한 목적
- **팀 일관성**: 모든 팀원이 동일한 스타일
- **지속적 개선**: 첫 구현은 단순하게, 점진적으로 개선

## 실제 적용 예시

### 에픽-스토리-태스크 구조
```
Epic: CHAT2 여행 정보 수집 시스템 (3주)
├── Story 1: Follow-up 질문 생성 시스템 (5일)
│   ├── Task 1-1: FollowUpQuestionGenerator 구현 (4시간)
│   │   └── PR #1: 질문 생성 로직 (~150줄)
│   ├── Task 1-2: TravelInfoValidator 구현 (3시간)
│   │   └── PR #2: 필수 정보 검증 (~100줄)
│   └── Task 1-3: 질문 템플릿 관리 (2시간)
│       └── PR #3: 템플릿 로더 구현 (~80줄)
│
├── Story 2: 사용자 입력 파싱 시스템 (4일)
│   ├── Task 2-1: NaturalLanguageParser 구현 (4시간)
│   │   └── PR #4: LLM 파싱 로직 (~200줄)
│   ├── Task 2-2: 날짜/예산 추출 로직 (3시간)
│   │   └── PR #5: 정규식 파서 (~120줄)
│   └── Task 2-3: 파싱 결과 검증 (2시간)
│       └── PR #6: 검증 로직 + 테스트 (~150줄)
│
└── Story 3: 정보 수집 상태 관리 (3일)
    ├── Task 3-1: TravelContext 구현 (3시간)
    │   └── PR #7: 컨텍스트 관리 (~130줄)
    ├── Task 3-2: Redis 캐싱 구현 (4시간)
    │   └── PR #8: 캐시 서비스 (~180줄)
    └── Task 3-3: 진행률 계산 로직 (2시간)
        └── PR #9: Progress Calculator (~100줄)
```

## 📝 PR 작성 템플릿

### PR 제목 형식
```
[Epic명/Story번호-Task번호] 구현 내용 요약
예: [CHAT2-정보수집/S1-T1] FollowUpQuestionGenerator 구현
```

### PR 본문 템플릿
```markdown
## 📌 개요
- **Epic**: CHAT2 여행 정보 수집 시스템
- **Story**: S1. Follow-up 질문 생성 시스템
- **Task**: T1. FollowUpQuestionGenerator 구현
- **예상 소요시간**: 4시간
- **실제 소요시간**: 3.5시간

## 🎯 구현 목적
### 전체 시스템에서의 역할
- 사용자가 입력한 여행 정보를 분석하여 누락된 필수 정보를 파악
- 자연스러운 대화형 질문을 생성하여 정보 수집 완성도 향상
- CHAT2 도메인의 핵심 기능으로 LLM과 사용자 간 브릿지 역할

### 이 코드가 필요한 이유
- 기존: 사용자가 모든 정보를 한 번에 입력해야 함 (폼 방식)
- 개선: 대화를 통해 점진적으로 정보 수집 (자연스러운 UX)
- 효과: 사용자 이탈률 감소, 정보 수집 완성도 향상

## 🏗️ 설계 결정 사항
### 왜 이런 구조를 선택했는가?
1. **Template Method Pattern 사용**
   - 이유: 질문 생성 로직의 공통 플로우 정의
   - 장점: 새로운 질문 타입 추가 시 확장 용이

2. **Spring AI ChatModel 사용**
   - 이유: LLM 추상화로 모델 변경 유연성 확보
   - 대안: OpenAI API 직접 호출 (❌ 벤더 종속성)

3. **Record 타입 사용 (FollowUpQuestionDto)**
   - 이유: 불변 객체로 스레드 안전성 보장
   - 장점: 간결한 코드, 자동 equals/hashCode

## ✅ 구현 내용
### 주요 변경사항
- `FollowUpQuestionGenerator.java` 신규 구현
  - 필수 정보 체크 로직
  - 컨텍스트 기반 질문 생성
  - 다국어 지원 준비

- `FollowUpQuestionDto.java` Record 추가
  - 질문 타입, 내용, 옵션 정의

- 테스트 코드 추가 (커버리지 85%)
  - 단위 테스트: 7개
  - 통합 테스트: 3개

## 🔗 의존성 및 영향 범위
### 사용하는 컴포넌트
- `TravelInfoValidator`: 정보 완성도 검증
- `ChatModel` (Spring AI): LLM 통신
- `TravelContext`: 대화 컨텍스트 관리

### 이 코드를 사용하는 곳
- `TravelInfoCollectionService`: 메인 수집 플로우
- `UnifiedChatController`: API 엔드포인트
- `ChatServiceImpl`: 채팅 서비스 통합

### 영향 범위
- 신규 기능이므로 기존 코드 영향 없음
- 향후 `TravelQuestionFlowEngine`과 통합 예정

## 🧪 테스트
### 테스트 시나리오
- [x] 목적지 누락 시 질문 생성
- [x] 날짜 누락 시 질문 생성
- [x] 예산 누락 시 질문 생성
- [x] 모든 정보 완료 시 null 반환
- [x] 컨텍스트 기반 질문 개인화
- [x] LLM 타임아웃 처리
- [x] 동시성 테스트 (100 요청)

### 테스트 결과
```
테스트 통과: 10/10
코드 커버리지: 85%
성능: 평균 응답시간 230ms
```

## 📊 코드 메트릭
- **추가된 줄**: 145 (로직) + 95 (테스트) + 15 (설정)
- **복잡도**: Cyclomatic Complexity 6 (양호)
- **중복 코드**: 0%
- **코딩 컨벤션 준수**: 100%

## 🔄 다음 단계
- Story 1의 Task 2로 진행 예정
- `TravelInfoValidator` 구현 (3시간 예상)

## 📝 리뷰 체크리스트
- [ ] 코드가 PR 목적에 부합하는가?
- [ ] 테스트가 충분한가?
- [ ] 에러 처리가 적절한가?
- [ ] 성능 고려사항이 있는가?
- [ ] 문서화가 충분한가?
```