# 🧭 Compass 프로젝트 워크플로우 가이드

## 📋 목차
1. [프로젝트 개요](#프로젝트-개요)
2. [전체 시스템 아키텍처](#전체-시스템-아키텍처)
3. [사용자 여정 워크플로우](#사용자-여정-워크플로우)
4. [도메인별 상세 워크플로우](#도메인별-상세-워크플로우)
5. [개발 워크플로우](#개발-워크플로우)
6. [배포 및 운영 워크플로우](#배포-및-운영-워크플로우)

---

## 🎯 프로젝트 개요

**Compass**는 AI 기반 개인화 여행 계획 서비스입니다. 사용자의 선호도와 상황을 이해하여 맞춤형 여행 일정을 제공하는 것이 목표입니다.

### 핵심 가치
- **개인화**: 사용자 선호도 기반 맞춤 추천
- **실시간 대화**: 자연스러운 채팅 인터페이스
- **정확한 정보**: 실시간 API 연동으로 최신 정보 제공
- **확장성**: 마이크로서비스 아키텍처로 독립적 확장 가능

---

## 🏗️ 전체 시스템 아키텍처

```
┌─────────────────────────────────────────────────────────────┐
│                        Frontend (React)                      │
│                    [모바일 앱 / 웹 클라이언트]                 │
└────────────────────────┬────────────────────────────────────┘
                         │ HTTPS (JWT)
                         ▼
┌─────────────────────────────────────────────────────────────┐
│                   Spring Boot Backend                        │
│  ┌──────────────┬──────────────┬──────────────────────┐    │
│  │  USER Domain │  CHAT Domain │     TRIP Domain       │    │
│  │              │              │                        │    │
│  │  - 인증/인가  │  - 대화 관리   │  - 여행 계획           │    │
│  │  - 프로필 관리 │  - LLM 통합   │  - RAG 추천           │    │
│  │  - 선호도 설정 │  - Function   │  - 날씨 API           │    │
│  │              │    Calling    │  - 개인화 파이프라인      │    │
│  └──────────────┴──────────────┴──────────────────────┘    │
└─────────────────────────┬────────────────────────────────────┘
                         │
            ┌────────────┴────────────┐
            ▼                          ▼
    ┌──────────────┐          ┌──────────────┐
    │  PostgreSQL  │          │    Redis     │
    │              │          │              │
    │  - 사용자 정보 │          │  - 벡터 DB   │
    │  - 대화 기록  │          │  - 캐싱      │
    │  - 여행 계획  │          │  - 세션 관리  │
    └──────────────┘          └──────────────┘
            │                          │
            └────────────┬─────────────┘
                         ▼
    ┌─────────────────────────────────────────┐
    │           External Services              │
    │                                          │
    │  - Google Gemini 2.0 Flash (주 LLM)     │
    │  - OpenAI GPT-4o-mini (보조 LLM)        │
    │  - Perplexity API (최신 트렌드 검색)     │
    │  - 한국관광공사 Tour API (공식 정보)      │
    │  - Google Maps API (동선 최적화)         │
    │  - 날씨 API                             │
    └─────────────────────────────────────────┘
```

---

## 👤 사용자 여정 워크플로우

### 1. 회원가입 및 로그인 플로우
```
사용자 → [회원가입 요청] → USER Domain
                          ↓
                    비밀번호 암호화
                    프로필 생성
                    선호도 초기화
                          ↓
                    JWT 토큰 발급
                          ↓
                    [로그인 완료] → 사용자
```

### 2. 핵심 여행 계획 플로우 (단순화)
```
사용자: "도쿄 여행 가고 싶어"
         ↓
[1단계: 인텐트 라우팅]
IntentRouter (CHAT1)
  → 의도 분류: 여행 계획
         ↓
[2단계: 꼬리질문으로 정보 수집]
FollowUpQuestionService (CHAT2)
  Bot: "도쿄 여행 계획을 도와드리겠습니다! 언제 출발하실 예정인가요?"
  사용자: "다음달 15일"
  Bot: "며칠 동안 여행하실 계획인가요?"
  사용자: "3박 4일"
  Bot: "누구와 함께 가시나요?"
  사용자: "여자친구랑"
  Bot: "어떤 스타일의 여행을 선호하시나요? (휴양/관광/액티비티)"
  사용자: "관광 위주로"
  Bot: "예산은 얼마나 생각하고 계신가요?"
  사용자: "1인당 100만원"
         ↓
[TravelContext 저장]
  - 목적지: 도쿄
  - 출발일: 다음달 15일
  - 기간: 3박 4일
  - 동행: 여자친구
  - 스타일: 관광
  - 예산: 1인당 100만원
  → Redis에 사용자별 컨텍스트 저장
         ↓
[3단계: 장소 검색 및 통합]
PerplexityService + TourAPIService (TRIP1)
  - 꼬리질문으로 수집된 TravelContext 수신:
    * 저장된 모든 여행 정보를 Redis에서 가져옴
    * 원본 입력 + 5개 답변 모두 활용
  
  - Perplexity 검색 (최신 트렌드, 숨은 명소):
    * TravelContext 기반 쿼리 생성
    * 1차: "도쿄 3박4일 여자친구와 관광 여행 추천 장소 10곳. 예산 1인당 100만원"
    * 2차: "도쿄 커플이 좋아할 관광 명소와 맛집, 예산 100만원"
    * 개인화된 자연어 쿼리로 최신 정보 수집
  
  - 한국관광공사 Tour API 검색 (공식 정보):
    * TravelContext의 목적지 정보 활용
    * 지역 코드 설정 (도쿄는 일본이므로 다른 API 활용 가능)
    * 관광지 정보 조회 (영업시간, 입장료, 주소)
    * 축제/행사 정보 조회 (여행 기간 중)
    * 공식 추천 코스 조회
  
  - 데이터 통합:
    * Perplexity: 최신 트렌드, 현지인 추천
    * Tour API: 공식 정보, 정확한 위치/시간
    * 중복 제거 및 정보 병합
  → 30개 검증된 장소 리스트업
         ↓
[4단계: Gemini 동선 최적화]
GeminiOptimizer (CHAT2)
  - 3박 4일 일정 생성
  - 효율적인 여행 경로 만들기:
    * 방법1: 가까운 장소끼리 묶어서 이동
    * 방법2: 같은 지역은 같은 날 방문
    * 방법3: Gemini에게 "이 장소들 효율적으로 도는 순서 알려줘" 요청
    * 방법4: Google Maps로 실제 이동시간 확인 (선택)
  - 일정 짤 때 고려사항:
    * 너무 많이 걷지 않도록 (하루 10km 이내)
    * 영업시간 체크 (문 닫은 곳 가지 않기)
    * 각 장소별 관람시간 충분히 확보
    * 밥 먹을 시간, 쉬는 시간 포함
  - 시간대별 추천:
    * 오전: 사람 적은 관광지
    * 점심: 맛집 (미리 예약 가능한 곳)
    * 오후: 쇼핑이나 체험 활동
    * 저녁: 야경 명소나 밤 문화
         ↓
[5단계: 여행 계획 저장]
TripService (TRIP1)
  → DB 저장 및 응답 포맷팅
         ↓
사용자: 완성된 3박 4일 도쿄 여행 일정 수신
```

### 3. 간소화된 추천 플로우
```
사용자 선호도 수집 (꼬리질문)
         ↓
    TravelContext 저장 (Redis)
         ↓
    Perplexity 검색 (TravelContext 활용)
         ↓
    장소 리스트 생성
         ↓
    맞춤형 추천 제공
```

---

## 🔧 도메인별 상세 워크플로우

### USER Domain 워크플로우
```
책임: 사용자 관리 및 인증/인가

주요 컴포넌트:
├── UserController (REST API)
│   ├── /api/auth/signup
│   ├── /api/auth/login
│   └── /api/auth/refresh
│
├── AuthService (비즈니스 로직)
│   ├── 회원가입 처리
│   ├── JWT 토큰 생성/검증
│   └── 토큰 갱신
│
├── UserRepository (데이터 접근)
│   └── PostgreSQL 연동
│
└── Security Configuration
    ├── JWT Filter
    └── Spring Security 설정
```

### CHAT Domain 워크플로우 (핵심 도메인)
```
책임: AI 대화 관리, 인텐트 라우팅, 꼬리질문 시스템

주요 처리 흐름:
1. 메시지 입력
   ↓
2. 인텐트 라우팅 (CHAT1)
   ├── IntentRouter
   │   ├── 의도 분류 (여행계획/추천/정보)
   │   ├── 신뢰도 점수 계산
   │   └── 처리 플로우 결정
   ↓
3. 꼬리질문 시스템 (CHAT2)
   ├── FollowUpQuestionService
   │   ├── 필수 정보 체크 (목적지, 날짜, 기간, 동행, 예산)
   │   ├── 순차적 질문 생성
   │   ├── 답변 파싱 및 검증
   │   ├── TravelContext 구성
   │   └── Redis에 컨텍스트 저장
   ↓
4. LLM 처리 (Gemini 동선 최적화)
   ├── Primary: Gemini 2.0 Flash
   ├── 동선 최적화 방법
   │   ├── 방법1: 가까운 곳부터 방문
   │   │   └── 현재 위치에서 가장 가까운 다음 장소 선택
   │   ├── 방법2: 지역별로 묶어서 이동
   │   │   └── 같은 지역 장소들을 하루에 모아서 방문
   │   ├── 방법3: Google Maps 활용 (선택사항)
   │   │   └── 실제 대중교통/도보 시간 계산
   │   └── 방법4: Gemini에게 최적 경로 요청
   │       └── "이 장소들을 효율적으로 도는 순서 추천해줘"
   ├── 일정 생성 규칙
   │   ├── 관광지별 평균 체류시간 (2시간)
   │   ├── 이동시간 + 여유시간 20% 추가
   │   ├── 점심/저녁 시간 확보 (각 1.5시간)
   │   └── 하루 도보 10km 이내로 제한
   └── Spring AI 추상화 레이어
   ↓
5. 응답 생성 및 저장
```

### TRIP Domain 워크플로우
```
책임: Perplexity API 통합 및 여행 계획 저장

처리 흐름:
1. TravelContext 수신 (꼬리질문 완료 후)
   ├── Redis에서 저장된 TravelContext 가져오기
   │   ├── 목적지, 날짜, 기간, 동행, 예산 정보
   │   └── 사용자 선호도 및 추가 정보
   ↓
2. 장소 검색 (Perplexity + Tour API) (TRIP1)
   ├── PerplexityService (최신 트렌드)
   │   ├── TravelContext 기반 쿼리 생성
   │   │   └── 꼬리질문에서 수집된 모든 정보 활용
   │   ├── 템플릿 기반 검색 쿼리 생성
   │   │   ├── 종합: "{{목적지}} {{기간}} {{동행}} {{스타일}} 여행, 예산 {{예산}}"
   │   │   └── 맛집: "{{목적지}} {{동행}}이 좋아할 {{스타일}} 맛집"
   │   ├── 최대 2-3회 검색 제한
   │   └── 최신 트렌드, 숨은 명소 수집
   │
   ├── TourAPIService (공식 정보)
   │   ├── TravelContext의 목적지 정보 활용
   │   ├── 한국관광공사 API 호출
   │   │   ├── areaCode: 지역별 코드 (서울:1, 부산:6 등)
   │   │   ├── contentTypeId: 관광지(12), 음식점(39), 숙박(32)
   │   │   └── serviceKey: API 인증키
   │   ├── 정보 조회
   │   │   ├── 관광지 상세정보 (영업시간, 휴무일, 입장료)
   │   │   ├── 위치기반 검색 (GPS 좌표)
   │   │   ├── 축제/행사 정보 (TravelContext의 날짜 매칭)
   │   │   └── 추천 코스 조회
   │   └── 정확한 공식 정보 확보
   │
   └── 데이터 통합 및 검증
       ├── 중복 제거 (이름/주소 기반)
       ├── 정보 병합 (Perplexity 리뷰 + Tour API 공식정보)
       └── 우선순위 정렬 (인기도 + 거리 + 선호도)
   ↓
3. 장소 리스트 생성
   ├── 카테고리별 분류 (관광지/식당/숙박/액티비티)
   ├── 추천 이유 및 예상 비용
   └── Redis 캐싱 (24시간)
   ↓
4. 여행 계획 저장
   ├── Trip 엔티티 생성
   ├── 일정 JSONB 저장
   └── 사용자 연결
   ↓
5. 결과 반환
```

---

## 💻 개발 워크플로우

### 1. 기능 개발 프로세스 (필수 순서)
```
[요구사항 정의]
      ↓
[1. Entity 설계]
  - JPA 엔티티 생성
  - 관계 매핑 정의
      ↓
[2. Repository 개발]
  - JpaRepository 확장
  - 커스텀 쿼리 작성
      ↓
[3. Service 개발]
  - 비즈니스 로직 구현
  - 트랜잭션 관리
      ↓
[4. Controller 개발]
  - REST API 엔드포인트
  - 입력 검증
      ↓
[5. 테스트 작성]
  - Unit Test (@Tag("unit"))
  - Integration Test (@Tag("integration"))
      ↓
[6. CI/CD 검증]
  - ./gradlew unitTest
  - ./gradlew test
```

### 2. 브랜치 전략
```
main (production)
  ↓
develop (staging)
  ↓
feature/[domain]-[feature]
  - feature/user-auth
  - feature/chat-function
  - feature/trip-rag
  
fix/[domain]-[issue]
  - fix/chat-message-error
  - fix/trip-calculation
```

### 3. 로컬 개발 환경 설정
```bash
# 1. 환경 변수 설정 (.env 파일 필요)
export $(cat .env | grep -v '^#' | xargs)

# 2. 데이터베이스만 실행 (IDE 개발 시)
docker-compose up -d postgres redis

# 3. 애플리케이션 실행
JAVA_HOME=/opt/homebrew/Cellar/openjdk@17/17.0.16/libexec/openjdk.jdk/Contents/Home \
./gradlew bootRun

# 4. 테스트 실행 (Redis 불필요)
JAVA_HOME=/opt/homebrew/Cellar/openjdk@17/17.0.16/libexec/openjdk.jdk/Contents/Home \
./gradlew unitTest
```

### 4. 코드 리뷰 체크리스트
- [ ] Entity-Repository-Service-Controller 순서 준수
- [ ] 테스트 커버리지 80% 이상
- [ ] @Tag 어노테이션 추가 (unit/integration)
- [ ] API 문서 업데이트
- [ ] 에러 처리 구현
- [ ] 로깅 적절히 추가

---

## 🚀 배포 및 운영 워크플로우

### 1. CI/CD 파이프라인
```
[Push to GitHub]
      ↓
[GitHub Actions 트리거]
      ↓
[테스트 환경 구성]
  - PostgreSQL 컨테이너
  - Redis 컨테이너
      ↓
[테스트 실행]
  - Unit Tests
  - Integration Tests
      ↓
[빌드]
  - JAR 파일 생성
      ↓
[아티팩트 업로드]
      ↓
[배포 준비]
```

### 2. 모니터링 체계
```
애플리케이션
    ↓
Micrometer 메트릭 수집
    ↓
/actuator/prometheus 엔드포인트
    ↓
Prometheus 수집
    ↓
Grafana 대시보드
    
주요 모니터링 지표:
- API 응답 시간
- LLM 토큰 사용량
- 에러율
- 동시 사용자 수
- DB 연결 풀 상태
```

### 3. 운영 환경 프로파일
```yaml
default: 로컬 개발 (로컬 DB/Redis)
docker: Docker 컨테이너 환경
test: 테스트 환경
test-no-redis: CI/CD용 (Redis 없이)
production: AWS Elastic Beanstalk
```

---

## 🔍 구체적인 검색 예시

### 통합 검색 예시 (Perplexity + Tour API)
```
사용자 입력: "부산 여행 계획 짜줘"

[꼬리질문으로 TravelContext 수집]
- 목적지: 해운대
- 기간: 2박 3일  
- 동행: 친구들 (4명)
- 스타일: 액티비티
- 예산: 1인당 30만원
→ Redis에 TravelContext 저장

[Perplexity 검색] - TravelContext 활용
1차: "부산 해운대 2박3일 친구들과 액티비티 여행 추천 장소 10곳. 
     20-30대가 좋아할 만한 활동적인 관광지, 서핑, 요트, 
     스카이캡슐, 예산 1인당 30만원 수준"
2차: "부산 해운대 젊은층 인기 맛집, 가성비 좋은 곳"
* TravelContext의 모든 정보를 활용하여 쿼리 생성

[Tour API 검색] - TravelContext 활용
- areaCode: 6 (부산)
- contentTypeId: 12 (관광지)
- 검색 결과:
  * 해운대해수욕장 (영업시간: 24시간, 입장료: 무료)
  * 동백섬 (산책로 개방시간: 05:00-23:00)
  * 청사포 다릿돌전망대 (09:00-18:00, 휴무: 월요일)
  * SEA LIFE 부산아쿠아리움 (10:00-19:00, 입장료: 29,000원)

[통합 결과]
- Perplexity: "청사포 카페거리가 요즘 핫플"
- Tour API: "청사포 다릿돌전망대 월요일 휴무"
→ 통합: "청사포 카페거리 + 전망대 (월요일 제외)"
```

### Gemini 동선 최적화 예시
```
수집된 장소 리스트:
Day 1: 해운대해수욕장, 동백섬, 청사포, 미포
Day 2: 감천문화마을, 자갈치시장, 부평깡통시장, 용두산공원
Day 3: 태종대, 흰여울문화마을, 송도해상케이블카

동선 최적화 과정:
1. 지역별로 묶기 (같은 지역은 같은 날 방문)
   - 해운대 쪽: 해운대, 동백섬, 청사포, 미포
   - 남포동/중구 쪽: 자갈치, 부평, 용두산
   - 영도/송도 쪽: 태종대, 흰여울, 송도, 감천

2. 가까운 곳끼리 연결해서 동선 만들기
   Day 1: 해운대 → 동백섬(걸어서 20분) → 미포(걸어서 15분) → 청사포(열차 10분)
   Day 2: 감천 → 송도(버스 20분) → 자갈치(지하철 15분) → 부평/용두산(걸어서)
   Day 3: 태종대 → 흰여울(버스 15분) → 영도대교(걸어서) → 남포동

3. 시간 계산하기:
   - 유명 관광지: 2시간씩
   - 작은 관광지: 1시간씩
   - 밥 먹는 시간: 1시간 30분
   - 이동시간: 실제 시간 + 여유 20%

또는 Gemini에게 직접 물어보기:
"이 장소들을 3일 동안 효율적으로 도는 일정 짜줘. 
 너무 많이 걷지 않게 하고, 밥 먹을 시간도 넣어줘"
```

---

## 📊 성능 최적화 전략

### 1. LLM 최적화
- **프롬프트 캐싱**: 자주 사용되는 템플릿 캐싱
- **토큰 최적화**: 컨텍스트 윈도우 관리
- **병렬 처리**: Function Calling 동시 실행

### 2. 데이터베이스 최적화
- **인덱싱**: 자주 조회되는 컬럼 인덱스
- **JSONB 활용**: 유연한 데이터 구조
- **연결 풀링**: HikariCP 설정 최적화

### 3. 캐싱 전략
- **Redis 캐싱**: 자주 조회되는 데이터
- **벡터 캐싱**: 임베딩 결과 재사용
- **세션 관리**: JWT 토큰 캐싱

---

## 🔐 보안 고려사항

### 1. 인증/인가
- JWT 기반 stateless 인증
- 토큰 만료 시간 관리
- Refresh Token 구현

### 2. API 보안
- Rate Limiting
- CORS 설정
- SQL Injection 방지

### 3. 데이터 보안
- 비밀번호 BCrypt 암호화
- 환경 변수 관리 (.env)
- API 키 보안 관리

---

## 📝 팀 협업 가이드

### 역할별 책임
- **CHAT 팀**: LLM 통합, Function Calling, OCR
- **USER 팀**: 인증/인가, 프로필 관리
- **TRIP 팀**: 여행 계획, RAG 구현

### 커뮤니케이션
- Discord #compass-backend 채널
- 일일 스탠드업 미팅
- 주간 코드 리뷰

### 문서화
- API 문서: Swagger UI (/swagger-ui.html)
- 기술 문서: /docs 디렉토리
- 이슈 관리: GitHub Issues

---

## 🎯 현재 진행 상황

### 완료된 기능
- ✅ Spring Boot 기본 설정
- ✅ Docker Compose 환경
- ✅ JWT 인증 시스템
- ✅ LLM 통합 (Gemini, GPT-4)
- ✅ Function Calling 구현
- ✅ 프롬프트 템플릿 시스템
- ✅ 키워드 기반 템플릿 선택
- ✅ 사용자 컨텍스트 개인화

### 진행 중
- 🔄 RAG 기반 개인화 고도화
- 🔄 Function Calling과 템플릿 통합
- 🔄 Follow-up 질문 생성 확장

### 계획
- 📋 성능 최적화
- 📋 A/B 테스팅 시스템
- 📋 다국어 지원

---

## 💡 트러블슈팅 가이드

### 자주 발생하는 이슈

1. **Redis 연결 실패**
   ```bash
   # Redis 없이 테스트 실행
   ./gradlew unitTest
   ```

2. **Java 버전 문제**
   ```bash
   # Java 17 명시적 지정
   export JAVA_HOME=/opt/homebrew/Cellar/openjdk@17/17.0.16/libexec/openjdk.jdk/Contents/Home
   ```

3. **포트 충돌**
   ```bash
   # 다른 포트로 실행
   ./gradlew bootRun --args='--server.port=8081'
   ```

---

이 워크플로우 가이드는 Compass 프로젝트의 전체적인 흐름을 이해하는 데 도움이 되도록 작성되었습니다. 각 팀원은 자신의 도메인뿐만 아니라 전체 시스템과의 연계를 이해하고 개발에 참여해 주시기 바랍니다.