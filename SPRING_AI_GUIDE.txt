================================================================================
                    Spring AI 실전 가이드북 for Compass 프로젝트
================================================================================

작성일: 2025년 1월
프로젝트: Compass - AI 기반 개인화 여행 계획 서비스
버전: Spring AI 1.0.0-M5
참고: Context7 Documentation 기반 작성

================================================================================
목차
================================================================================
1. Spring AI란 무엇인가?
2. 왜 Spring AI를 사용하는가?
3. 빠른 시작 가이드
4. 핵심 컴포넌트 이해하기
5. Compass 프로젝트 실전 예제
6. RAG (Retrieval-Augmented Generation) 구현
7. 콜드 스타트 문제 해결
8. 멀티 LLM 오케스트레이션
9. 벡터 스토어 활용
10. 멀티모달 기능 (이미지/비디오 처리)
11. 문제 해결 및 팁

================================================================================
1. Spring AI란 무엇인가?
================================================================================

Spring AI는 Spring 생태계에서 AI 애플리케이션을 쉽게 개발할 수 있도록 지원하는 
프레임워크입니다. LangChain의 Java 버전이라고 생각하면 이해하기 쉽습니다.

핵심 특징:
- Spring Boot와 완벽한 통합
- 자동 구성(Auto-configuration) 지원
- 다양한 AI 모델 지원 (OpenAI, Gemini, Claude 등)
- 벡터 데이터베이스 통합
- RAG 패턴 내장 지원

================================================================================
2. 왜 Spring AI를 사용하는가?
================================================================================

우리 Compass 프로젝트에서 Spring AI를 선택한 이유:

1) Spring 네이티브
   - 이미 Spring Boot를 사용 중이므로 자연스러운 통합
   - 익숙한 어노테이션과 패턴 사용

2) 벡터 스토어 지원
   - Redis Vector Store를 통한 RAG 구현
   - 개인화 추천을 위한 유사도 검색

3) 멀티 LLM 지원
   - Gemini 2.5 Flash (일반 대화)
   - GPT-4o-mini (복잡한 계획)
   - 쉬운 모델 전환

4) Function Calling
   - Tour API, Weather API (AWS Lambda MCP)
   - Perplexity API (Spring AI 내부)
   - 17개 함수 자동 실행

================================================================================
3. 빠른 시작 가이드
================================================================================

### Step 1: 의존성 추가 (pom.xml)

<dependencies>
    <!-- Spring AI OpenAI -->
    <dependency>
        <groupId>org.springframework.ai</groupId>
        <artifactId>spring-ai-openai-spring-boot-starter</artifactId>
        <version>1.0.0-M5</version>
    </dependency>
    
    <!-- Spring AI Vertex AI Gemini -->
    <dependency>
        <groupId>org.springframework.ai</groupId>
        <artifactId>spring-ai-vertex-ai-gemini-spring-boot-starter</artifactId>
        <version>1.0.0-M5</version>
    </dependency>
    
    <!-- Spring AI Redis Vector Store -->
    <dependency>
        <groupId>org.springframework.ai</groupId>
        <artifactId>spring-ai-redis-spring-boot-starter</artifactId>
        <version>1.0.0-M5</version>
    </dependency>
</dependencies>

### Step 2: application.yml 설정

spring:
  ai:
    openai:
      api-key: ${OPENAI_API_KEY}
      chat:
        options:
          model: gpt-4o-mini
          temperature: 0.7
    vertex:
      ai:
        gemini:
          project-id: ${GOOGLE_CLOUD_PROJECT_ID}
          location: asia-northeast3
          chat:
            options:
              model: gemini-2.5-flash
              temperature: 0.7
    vectorstore:
      redis:
        index-name: compass-vector-index
        embedding-dimension: 1536

### Step 3: 환경 변수 설정

export OPENAI_API_KEY=sk-...
export GOOGLE_CLOUD_PROJECT_ID=your-project-id
export GOOGLE_CLOUD_LOCATION=asia-northeast3

================================================================================
4. 핵심 컴포넌트 이해하기
================================================================================

### 4.1 ChatModel - AI 대화 인터페이스

ChatModel은 AI 모델과 대화하는 핵심 인터페이스입니다.

@Service
public class ChatService {
    private final OpenAiChatModel openAiChatModel;
    private final VertexAiGeminiChatModel geminiChatModel;
    
    // 간단한 대화
    public String chat(String message) {
        ChatResponse response = geminiChatModel.call(
            new Prompt(message)
        );
        return response.getResult().getOutput().getContent();
    }
}

### 4.2 EmbeddingModel - 텍스트 벡터화

텍스트를 벡터로 변환하여 유사도 검색을 가능하게 합니다.

@Service
public class EmbeddingService {
    private final EmbeddingModel embeddingModel;
    
    public float[] embedText(String text) {
        return embeddingModel.embed(text);
    }
}

### 4.3 VectorStore - 벡터 데이터베이스

벡터화된 데이터를 저장하고 검색합니다.

@Service
public class VectorService {
    private final VectorStore vectorStore;
    
    public void saveDocument(String content, Map<String, Object> metadata) {
        Document doc = new Document(content, metadata);
        vectorStore.add(List.of(doc));
    }
    
    public List<Document> search(String query) {
        return vectorStore.similaritySearch(
            SearchRequest.builder()
                .query(query)
                .topK(5)
                .similarityThreshold(0.7)
                .build()
        );
    }
}

================================================================================
5. Compass 프로젝트 실전 예제
================================================================================

### 5.1 멀티 LLM 라우팅 구현

@Service
@RequiredArgsConstructor
public class LlmService {
    private final OpenAiChatModel openAiChatModel;
    private final VertexAiGeminiChatModel geminiChatModel;
    
    public String processMessage(String message, MessageType type) {
        // 메시지 타입에 따라 적절한 모델 선택
        ChatModel selectedModel = switch(type) {
            case SIMPLE_CHAT -> geminiChatModel;      // Gemini for 일반 대화
            case TRIP_PLANNING -> openAiChatModel;     // GPT-4 for 복잡한 계획
            default -> geminiChatModel;
        };
        
        // 시스템 프롬프트 추가
        var systemMessage = new SystemMessage(
            "당신은 친절한 여행 가이드입니다. 사용자에게 도움이 되는 정보를 제공해주세요."
        );
        
        var userMessage = new UserMessage(message);
        
        ChatResponse response = selectedModel.call(
            new Prompt(List.of(systemMessage, userMessage))
        );
        
        return response.getResult().getOutput().getContent();
    }
}

### 5.2 OCR 기능 구현 (Vision API)

@Service
@RequiredArgsConstructor
public class OcrService {
    private final OpenAiChatModel openAiChatModel;
    
    public String extractTextFromImage(MultipartFile image) throws IOException {
        byte[] imageBytes = image.getBytes();
        
        // 이미지와 함께 메시지 생성
        var userMessage = new UserMessage(
            "이미지에서 텍스트를 추출해주세요. 여행 관련 정보(날짜, 장소, 가격 등)를 중점적으로 파악해주세요.",
            List.of(new Media(MimeTypeUtils.IMAGE_PNG, imageBytes))
        );
        
        // Vision 모델 사용
        ChatResponse response = openAiChatModel.call(
            new Prompt(
                List.of(userMessage),
                OpenAiChatOptions.builder()
                    .withModel("gpt-4-vision-preview")
                    .withMaxTokens(500)
                    .build()
            )
        );
        
        return response.getResult().getOutput().getContent();
    }
}

### 5.3 Function Calling 구현 (하이브리드 MCP)

// Lambda MCP 호출 Function
@Bean
@Description("키워드로 관광지를 검색합니다")
public Function<TourKeywordSearchRequest, TourKeywordSearchResponse> searchTourByKeyword() {
    return request -> {
        // Lambda MCP 서버 호출
        TourSearchResult result = tourMCPService.searchByKeyword(
            request.keyword, request.pageNo, request.numOfRows
        );
        return TourKeywordSearchResponse.builder()
            .success(true)
            .places(result.getPlaces())
            .build();
    };
}

// Spring AI 내부 Perplexity Function
@Bean
@Description("현재 트렌딩하는 인기 여행지를 검색합니다")
public Function<TrendingSearchRequest, TrendingSearchResponse> searchTrendingDestinations() {
    return request -> {
        // Perplexity API 직접 호출 (Spring 내부)
        TrendingSearchResult result = perplexityService.searchTrendingDestinations(
            request.region, request.season, request.category
        );
        return TrendingSearchResponse.builder()
            .success(true)
            .destinations(result.getDestinations())
            .build();
    };
}

================================================================================
6. RAG (Retrieval-Augmented Generation) 구현
================================================================================

RAG는 벡터 DB에서 관련 정보를 검색한 후, 그 정보를 바탕으로 AI가 답변하는 패턴입니다.

### 6.1 데이터 저장 (Embedding)

@Service
@RequiredArgsConstructor
public class DataIngestionService {
    private final VectorStore vectorStore;
    private final EmbeddingModel embeddingModel;
    
    public void saveUserPreference(Long userId, String preference) {
        // 문서 생성 (메타데이터 포함)
        Document doc = new Document(
            preference,
            Map.of(
                "userId", userId.toString(),
                "type", "preference",
                "timestamp", LocalDateTime.now().toString()
            )
        );
        
        // 벡터 스토어에 저장 (자동으로 임베딩됨)
        vectorStore.add(List.of(doc));
    }
}

### 6.2 RAG 기반 추천 구현

@Service
@RequiredArgsConstructor
public class RagRecommendationService {
    private final VectorStore vectorStore;
    private final OpenAiChatModel chatModel;
    
    public String generateRecommendation(Long userId, String query) {
        // 1. 벡터 검색으로 관련 문서 찾기
        List<Document> relevantDocs = vectorStore.similaritySearch(
            SearchRequest.builder()
                .query(query)
                .topK(5)
                .filterExpression("userId == '" + userId + "'")  // 메타데이터 필터
                .similarityThreshold(0.7)
                .build()
        );
        
        // 2. 검색된 문서로 컨텍스트 구성
        String context = relevantDocs.stream()
            .map(Document::getContent)
            .collect(Collectors.joining("\n"));
        
        // 3. LLM에 컨텍스트와 함께 질문
        var systemMessage = new SystemMessage(
            "다음 컨텍스트를 바탕으로 사용자에게 맞춤형 여행을 추천해주세요:\n" + context
        );
        
        var userMessage = new UserMessage(query);
        
        ChatResponse response = chatModel.call(
            new Prompt(List.of(systemMessage, userMessage))
        );
        
        return response.getResult().getOutput().getContent();
    }
}

### 6.3 Spring AI의 RetrievalAugmentationAdvisor 사용

더 간단한 방법으로 Spring AI의 내장 RAG 기능을 사용할 수 있습니다:

@Service
@RequiredArgsConstructor
public class SimpleRagService {
    private final ChatClient chatClient;
    private final VectorStore vectorStore;
    
    public String askWithRag(String question) {
        // RAG Advisor 생성
        var ragAdvisor = RetrievalAugmentationAdvisor.builder()
            .documentRetriever(VectorStoreDocumentRetriever.builder()
                .vectorStore(vectorStore)
                .similarityThreshold(0.7)
                .topK(5)
                .build())
            .build();
        
        // ChatClient와 함께 사용
        return chatClient.prompt()
            .advisors(ragAdvisor)
            .user(question)
            .call()
            .content();
    }
}

================================================================================
7. 콜드 스타트 문제 해결
================================================================================

신규 사용자에게도 좋은 추천을 제공하는 방법:

### 7.1 신규 사용자 감지

@Service
public class ColdStartService {
    private final VectorStore vectorStore;
    
    public boolean isNewUser(Long userId) {
        List<Document> userDocs = vectorStore.similaritySearch(
            SearchRequest.builder()
                .query("user preferences")
                .topK(1)
                .filterExpression("userId == '" + userId + "'")
                .build()
        );
        return userDocs.isEmpty();
    }
}

### 7.2 온보딩 질문 생성

@Service
public class OnboardingService {
    
    public OnboardingQuestions createQuestions() {
        return OnboardingQuestions.builder()
            .questions(List.of(
                "어떤 스타일의 여행을 선호하시나요? (휴양/관광/액티비티)",
                "여행 예산은 어느 정도로 생각하고 계신가요?",
                "선호하는 여행 기간은 며칠 정도인가요?",
                "특별히 가보고 싶은 나라나 도시가 있으신가요?",
                "여행에서 가장 중요하게 생각하는 것은 무엇인가요?"
            ))
            .build();
    }
}

### 7.3 암묵적 선호도 추출

@Service
public class ImplicitPreferenceExtractor {
    private final VectorStore vectorStore;
    
    public void extractFromMessage(Long userId, String message) {
        Set<String> keywords = extractKeywords(message);
        
        StringBuilder preferences = new StringBuilder();
        
        if (keywords.contains("해변") || keywords.contains("바다")) {
            preferences.append("해변/바다 선호 ");
        }
        if (keywords.contains("산") || keywords.contains("등산")) {
            preferences.append("산/자연 선호 ");
        }
        if (keywords.contains("도시") || keywords.contains("쇼핑")) {
            preferences.append("도시/쇼핑 선호 ");
        }
        
        if (preferences.length() > 0) {
            Document doc = new Document(
                preferences.toString(),
                Map.of("userId", userId.toString(), "type", "implicit_preference")
            );
            vectorStore.add(List.of(doc));
        }
    }
}

================================================================================
8. 멀티 LLM 오케스트레이션
================================================================================

### 8.1 모델별 특성 활용

@Configuration
public class LlmConfig {
    
    @Bean
    public LlmRouter llmRouter(
            OpenAiChatModel openAi,
            VertexAiGeminiChatModel gemini) {
        
        return LlmRouter.builder()
            // Gemini: 빠른 응답, 일반 대화
            .addRoute("simple_chat", gemini)
            .addRoute("greeting", gemini)
            .addRoute("weather_info", gemini)
            
            // GPT-4: 복잡한 추론, 계획 수립
            .addRoute("trip_planning", openAi)
            .addRoute("itinerary_creation", openAi)
            .addRoute("complex_analysis", openAi)
            
            .defaultModel(gemini)
            .build();
    }
}

### 8.2 의도 분류 기반 라우팅

@Service
public class IntentBasedRouter {
    private final Map<Intent, ChatModel> modelMap;
    
    public String route(String message) {
        Intent intent = classifyIntent(message);
        ChatModel model = modelMap.getOrDefault(intent, defaultModel);
        
        return model.call(new Prompt(message))
            .getResult().getOutput().getContent();
    }
    
    private Intent classifyIntent(String message) {
        // 키워드 기반 간단한 분류
        if (message.contains("여행 계획") || message.contains("일정")) {
            return Intent.TRIP_PLANNING;
        }
        if (message.contains("날씨") || message.contains("기온")) {
            return Intent.WEATHER;
        }
        return Intent.GENERAL_CHAT;
    }
}

================================================================================
9. 벡터 스토어 활용
================================================================================

### 9.1 Redis Vector Store 설정

@Configuration
public class VectorStoreConfig {
    
    @Bean
    public VectorStore redisVectorStore(
            JedisConnectionFactory jedis,
            EmbeddingModel embeddingModel) {
        
        return RedisVectorStore.builder()
            .jedisConnectionFactory(jedis)
            .embeddingModel(embeddingModel)
            .indexName("compass-vectors")
            .prefix("doc:")
            .metadataFields(List.of(
                MetadataField.text("userId"),
                MetadataField.text("type"),
                MetadataField.numeric("rating")
            ))
            .build();
    }
}

### 9.2 메타데이터 필터링 활용

@Service
public class FilteredSearchService {
    private final VectorStore vectorStore;
    
    public List<Document> searchWithFilters(String query, Long userId, String type) {
        // 복잡한 필터 표현식
        String filter = String.format(
            "userId == '%s' && type == '%s' && rating >= 4",
            userId, type
        );
        
        return vectorStore.similaritySearch(
            SearchRequest.builder()
                .query(query)
                .topK(10)
                .filterExpression(filter)
                .similarityThreshold(0.6)
                .build()
        );
    }
}

### 9.3 배치 처리 최적화

@Service
public class BatchVectorService {
    private final VectorStore vectorStore;
    private final BatchingStrategy batchingStrategy;
    
    public void saveDocumentsBatch(List<String> contents) {
        // 문서 생성
        List<Document> documents = contents.stream()
            .map(content -> new Document(content, Map.of()))
            .toList();
        
        // 배치 전략 적용 (토큰 제한 고려)
        List<List<Document>> batches = batchingStrategy.batch(documents);
        
        // 배치별로 저장
        for (List<Document> batch : batches) {
            vectorStore.add(batch);
        }
    }
}

================================================================================
10. 멀티모달 기능 (이미지/비디오 처리)
================================================================================

Spring AI는 텍스트뿐만 아니라 이미지, 비디오, 오디오 등 다양한 형태의 데이터를 처리할 수 있습니다.

### 10.1 이미지 처리 (Vision API)

@Service
@RequiredArgsConstructor
public class MultimodalService {
    private final OpenAiChatModel openAiChatModel;
    
    // 이미지 파일과 텍스트를 함께 처리
    public String analyzeImage(byte[] imageData, String question) {
        var userMessage = new UserMessage(
            question,
            new Media(MimeTypeUtils.IMAGE_PNG, imageData)
        );
        
        ChatResponse response = openAiChatModel.call(
            new Prompt(userMessage,
                OpenAiChatOptions.builder()
                    .model("gpt-4o")  // GPT-4 Vision 모델
                    .build()
            )
        );
        
        return response.getResult().getOutput().getContent();
    }
    
    // URL로부터 이미지 처리
    public String analyzeImageFromUrl(String imageUrl, String question) {
        var userMessage = new UserMessage(
            question,
            new Media(MimeTypeUtils.IMAGE_PNG, URI.create(imageUrl))
        );
        
        return openAiChatModel.call(new Prompt(userMessage))
            .getResult().getOutput().getContent();
    }
}

### 10.2 Vertex AI 멀티모달 임베딩

Vertex AI는 이미지, 텍스트, 비디오를 동일한 벡터 공간에 임베딩할 수 있습니다.

@Service
@RequiredArgsConstructor
public class MultimodalEmbeddingService {
    private final VertexAiMultimodalEmbeddingModel embeddingModel;
    
    public void embedMultimodal() {
        // 이미지와 비디오 미디어 생성
        Media imageMedia = new Media(
            MimeTypeUtils.IMAGE_PNG, 
            new ClassPathResource("/travel-photo.png")
        );
        
        Media videoMedia = new Media(
            new MimeType("video", "mp4"),
            new ClassPathResource("/travel-video.mp4")
        );
        
        // 멀티모달 문서 생성
        Document document = new Document(
            "이 여행 사진과 비디오를 설명해주세요",
            List.of(imageMedia, videoMedia),
            Map.of("type", "travel_content")
        );
        
        // 임베딩 생성
        DocumentEmbeddingRequest request = new DocumentEmbeddingRequest(
            List.of(document),
            EmbeddingOptions.EMPTY
        );
        
        EmbeddingResponse response = embeddingModel.call(request);
        
        // 이미지와 텍스트가 같은 벡터 공간에 있어 상호 검색 가능
        // 예: 텍스트로 이미지 검색, 이미지로 비디오 검색
    }
}

### 10.3 Compass 프로젝트에서의 활용

@Service
public class TravelDocumentProcessor {
    private final OpenAiChatModel visionModel;
    private final VectorStore vectorStore;
    
    // 여행 티켓, 메뉴, 안내판 등의 이미지 처리
    public void processTravelDocument(MultipartFile image, Long userId) {
        byte[] imageBytes = image.getBytes();
        
        // 1. OCR 및 정보 추출
        String extractedInfo = visionModel.call(
            new Prompt(
                new UserMessage(
                    "이미지에서 날짜, 장소, 가격 정보를 추출해주세요",
                    new Media(MimeTypeUtils.IMAGE_PNG, imageBytes)
                ),
                OpenAiChatOptions.builder()
                    .model("gpt-4o")
                    .build()
            )
        ).getResult().getOutput().getContent();
        
        // 2. 추출된 정보를 벡터화하여 저장
        Document doc = new Document(
            extractedInfo,
            Map.of(
                "userId", userId.toString(),
                "type", "travel_document",
                "originalFilename", image.getOriginalFilename()
            )
        );
        
        vectorStore.add(List.of(doc));
    }
}

================================================================================
11. 하이브리드 MCP 아키텍처 구현
================================================================================

### 11.1 Lambda MCP 서버 구조

// Tour API Lambda Function (tour-mcp/index.js)
exports.handler = async (event) => {
    const { method, params } = JSON.parse(event.body);
    
    switch (method) {
        case 'tour/searchKeyword':
            return await searchByKeyword(params);
        case 'tour/searchArea':
            return await searchByArea(params);
        // ... 8개 메서드
    }
};

// Spring에서 Lambda MCP 호출
@Service
public class TourMCPService {
    public TourSearchResult searchByKeyword(String keyword) {
        MCPRequest request = MCPRequest.builder()
            .method("tour/searchKeyword")
            .params(Map.of("keyword", keyword))
            .build();
        
        return callLambdaMCP(request, TourSearchResult.class);
    }
}

### 11.2 Perplexity 내부 통합

@Service
public class PerplexityService {
    // Spring AI 내부에서 직접 호출
    public TrendingSearchResult searchTrendingDestinations(
            String region, String season, String category) {
        
        // Perplexity API 직접 호출
        PerplexityResponse response = callPerplexityAPI(
            buildTrendingPrompt(region, season, category),
            "pplx-70b-online",
            0.2
        );
        
        return parseTrendingResponse(response);
    }
}

### 11.3 다단계 개인화 파이프라인

@Service
public class MultiStagePersonalizationService {
    
    public PersonalizedRecommendationResult getPersonalizedRecommendations(
            String userId, RecommendationContext context) {
        
        // Stage 1: Redis Vector Store
        PersonalizationResult stage1 = filterByPersonalization(userId, context);
        
        // Stage 2: Perplexity (Spring AI 내부)
        TrendingResult stage2 = filterByTrending(stage1, context);
        
        // Stage 3: Tour API (Lambda MCP)
        List<EnrichedRecommendation> stage3 = enrichWithTourAPI(stage2, context);
        
        return buildFinalResult(stage3);
    }
}

================================================================================
12. 문제 해결 및 팁
================================================================================

### 11.1 일반적인 문제와 해결책

문제: "토큰 한도 초과 에러"
해결: 
- 프롬프트 길이 제한
- 컨텍스트 요약 사용
- 스트리밍 응답 활용

@Service
public class TokenOptimizer {
    
    public String optimizePrompt(String longContext) {
        // 긴 컨텍스트를 요약
        if (longContext.length() > 3000) {
            return summarize(longContext);
        }
        return longContext;
    }
}

문제: "응답 속도가 느림"
해결:
- Gemini 사용 (GPT-4보다 빠름)
- 캐싱 적용
- 비동기 처리

@Service
public class CachedLlmService {
    @Cacheable(value = "llm-responses", key = "#message")
    public String getCachedResponse(String message) {
        return llmService.process(message);
    }
}

문제: "벡터 검색 정확도가 낮음"
해결:
- 임베딩 모델 개선
- 메타데이터 필터 추가
- 유사도 임계값 조정

### 11.2 성능 최적화 팁

1. 스트리밍 응답 사용
@RestController
public class StreamController {
    
    @GetMapping(value = "/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<String> stream(@RequestParam String message) {
        return chatModel.stream(new Prompt(message))
            .map(response -> response.getResult().getOutput().getContent());
    }
}

2. 병렬 처리
@Service
public class ParallelLlmService {
    
    @Async
    public CompletableFuture<String> processAsync(String message) {
        return CompletableFuture.completedFuture(
            chatModel.call(new Prompt(message))
                .getResult().getOutput().getContent()
        );
    }
}

3. 연결 풀 설정
spring:
  ai:
    openai:
      connection:
        timeout: 30s
        max-connections: 100

### 11.3 디버깅 팁

1. 로깅 활성화
logging:
  level:
    org.springframework.ai: DEBUG

2. 메트릭 모니터링
@Component
public class LlmMetrics {
    private final MeterRegistry meterRegistry;
    
    public void recordLatency(long latency) {
        meterRegistry.timer("llm.latency").record(latency, TimeUnit.MILLISECONDS);
    }
}

### 11.4 보안 고려사항

1. API 키 관리
- 절대 코드에 하드코딩하지 않기
- 환경 변수 또는 시크릿 매니저 사용

2. 입력 검증
@Service
public class InputValidator {
    
    public String sanitizeInput(String input) {
        // 악의적인 프롬프트 필터링
        return input.replaceAll("[<>\"']", "");
    }
}

3. 사용량 제한
@Component
public class RateLimiter {
    
    @RateLimited(limit = 100, duration = 1, unit = TimeUnit.HOURS)
    public String processWithLimit(String message) {
        return llmService.process(message);
    }
}

================================================================================
마무리
================================================================================

Spring AI는 Spring 개발자가 AI 애플리케이션을 쉽게 만들 수 있도록 도와주는 
강력한 프레임워크입니다. 

우리 Compass 프로젝트에서는:
- Gemini 2.5 Flash로 빠른 응답
- GPT-4o-mini로 정확한 계획
- Redis Vector Store로 개인화
- RAG로 맞춤형 추천
- 콜드 스타트 해결로 신규 사용자 대응

을 구현했습니다.

추가 학습 자료:
- 공식 문서: https://docs.spring.io/spring-ai/reference/
- GitHub: https://github.com/spring-projects/spring-ai
- 예제 프로젝트: https://github.com/spring-projects/spring-ai-examples

질문이 있으면 팀 슬랙 채널에 문의해주세요!

Happy Coding! 🚀